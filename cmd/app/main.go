// Copyright (C) 2016 Eneo Tecnologia S.L.
// Diego Fern√°ndez Barrera <bigomby@gmail.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"crypto/tls"
	"flag"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"regexp"
	"net"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"strconv"
	"syscall"
	"time"
	"os/exec"
	"github.com/Sirupsen/logrus"
	"gopkg.in/yaml.v2"

	"github.com/redBorder/rb-malware-agent/client"
	"github.com/redBorder/rb-malware-agent/snortcontrol"
)

////////////////
// Structures //
////////////////

// Config stores the general configuration for the app
type Config struct {
	URL           string `yaml:"url"`                  // API URL
	Interval      int    `yaml:"interval"`             // Interval between queries
	SocketTimeout int    `yaml:"snort_socket_timeout"` // Max time to wait for snort responses
	Insecure      bool   `yaml:"insecure"`             // Don't verify SSL cert
	GroupConfig   []struct {
		MinScore           int    `yaml:"min_score"`          // Scores greater than this values are blacklisted
		IPBlacklist        string `yaml:"ip_blacklist"`       // Path for the file
		IPWhitelist        string `yaml:"ip_whitelist"`       // Path for the file
		HashBlacklist      string `yaml:"hash_blacklist"`     // Path for the file
		HashWhitelist      string `yaml:"hash_whitelist"`     // Path for the file
		URLBlacklist       string `yaml:"url_blacklist"`	  // Path for the file
		SocketPath         string `yaml:"snort_socket_path"`  // Path for the snort control socket
		SnortInstancePath  string `yaml:"snort_instance_path"` // Path for the snort instance
	} `yaml:"instances"`
}

////////////////////////////
// Constants and globals  //
////////////////////////////

const (
	snortIPReloadCode   = 1361 // Snort control code for IP reloading
	snortHashReloadCode = 1471 // Snort control code for HASH reloading
	snortMessageTimeout = 5000 // Max time to wait for snort responses
)

// Options stores the configuration of the application
var (
	githash        string // SHA from the current commit
	version        string // Current version of the app
	configFileName string // File name of the provided config file
	config         Config // Structure that stores the parsed configuration
)

///////////////
// Functions //
///////////////

// Used for parsing params and parse config file
func init() {
	debug := flag.Bool("debug", false, "Print debug info")
	versionFlag := flag.Bool("version", false, "Show version")
	configFileFlag := flag.String("config", "", "Config file")
	flag.Parse()

	if *versionFlag {
		fmt.Println("Version: " + version)
		fmt.Println("SHA: " + githash)
		os.Exit(0)
	}

	if *debug {
		logrus.SetLevel(logrus.DebugLevel)
	}

	configFileName = *configFileFlag

	if len(configFileName) == 0 {
		flag.Usage()
		os.Exit(0)
	}
	logrus.Debugf(configFileName)
	options, err := ioutil.ReadFile(configFileName)
	if err != nil {
		logrus.Fatal(err)
	}

	err = yaml.Unmarshal([]byte(options), &config)
	if err != nil {
		logrus.Fatal(err)
	}

	if len(config.URL) == 0 {
		logrus.Fatal("No URL provided")
	}
}

func lookUpSnortBindings(dirPath string) ([]string, error) {
	var matches []string

	// Regular expression pattern to match directory names
	pattern := `snort-binding-\d+`

	// Walk through the directory and match the pattern
	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Check if the path is a directory and matches the pattern
		if info.IsDir() {
			matched, _ := regexp.MatchString(pattern, info.Name())
			if matched {
				matches = append(matches, path)
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return matches, err
}


func fetchLastSIDFromDir(dirPath string) (int, error) {
	var lastSid int = 0
	var bindingIds []int
	snortBindings, err := lookUpSnortBindings(dirPath)

	if err != nil {
		logrus.Debugf("Could not lookup snort bindings")
		return 0, err
	}

	for i := 0; i < len(snortBindings); i++ {
		ruleFiles, err := filepath.Glob(filepath.Join(snortBindings[i], "*.rules"))
		if err != nil {
			logrus.Warn(err)
			return 0, err
		}
	
		logrus.Debugf("Files in ->" + snortBindings[i] + " -> " + strconv.FormatInt(int64(len(ruleFiles)), 10))
	
		// Regular expression to match the last SID value
		sidRegex := regexp.MustCompile(`sid:(\d+);`)
	
		// Iterate over each .rules file
		for _, file := range ruleFiles {
			logrus.Debugf("Looking for rules in ->" + file)
			// Read the file content
			content, err := ioutil.ReadFile(file)
			if err != nil {
				return 0, err
			}
	
			// Find all matches of the SID regex in the file content
			matches := sidRegex.FindAllStringSubmatch(string(content), -1)
	
			// Extract the last SID value from each match and convert it to an integer
			for _, match := range matches {
				sid, err := strconv.Atoi(match[1])
				if err != nil {
					return 0, err
				}
				if sid > lastSid {
					lastSid = sid
				}
			}
			bindingIds = append(bindingIds, lastSid)
			lastSid = 0
		}
		
		for i := 0; i < len(bindingIds); i++ {
			if bindingIds[i] > lastSid {
				lastSid = bindingIds[i]
			}
		}
	}
	return lastSid, nil
}

func GetLastSid() int {
	var lastSid int = 0

	for instance := 0; instance < len(config.GroupConfig); instance++ {
		SnortInstancePath := config.GroupConfig[instance].SnortInstancePath
		logrus.Debugf("[yaml] -> Looking for rules in instance -> " + SnortInstancePath)
		// Call fetchLastSIDFromDir to get the last SID from the directory
		instanceLastSid, err := fetchLastSIDFromDir(SnortInstancePath)
		if err != nil {
			// Handle the error appropriately
			// For example, log the error or return a default value
			fmt.Println("Error:", err)
			return lastSid
		}

		// Update the lastSid if a higher SID is found
		if instanceLastSid > lastSid {
			lastSid = instanceLastSid
		}
	}
	logrus.Debugf("Got last rule id for the instances -> " +strconv.FormatInt(int64(lastSid), 10))
	return lastSid
}

func pararelNotify(instance, controlCode, timeout int) {
	logrus.Debugf("Will send signal to -> " + strconv.FormatInt(int64(instance), 10))
	if _, err := os.Stat(config.GroupConfig[instance].SocketPath + "/instance-" +
		strconv.FormatInt(int64(instance), 10) + "/SNORT.sock"); os.IsNotExist(err) {
		return
	}

	socket, err := net.Dial("unix", config.GroupConfig[instance].SocketPath+"instance-"+strconv.FormatInt(int64(instance), 10)+"/SNORT.sock")
	if err != nil {
		logrus.Warn(err)
	}
	defer socket.Close()

	logrus.Debugf("Sending code: %d to %s", controlCode,
		"instance-"+strconv.FormatInt(int64(instance), 10))

	code, message, err := snortcontrol.Notify(
		socket,
		controlCode,
		timeout,
	)

	if err != nil {
		logrus.Warn(err)
		return
	}

	if code != 0 {
		logrus.Warn("Snort notify error: " + message)
	}
}
func UpdateRules(){

	// Command to execute
	logrus.Infof("Reloading snort, new url blacklist detected...")
	cmd := exec.Command("service", "snortd", "reload")

	// Run the command
	logrus.Debugf("Awaiting for snortd, main loop is blocked")
	err := cmd.Run()
	if err != nil {
		logrus.Fatal(err)
	}

	// Print a success message
	logrus.Infof("Snort service reloaded successfully.")
}

func main() {
	var err error
	var instanceData []client.InstanceData
	httpClient := &http.Client{}

	// Set the client to skip SSL verification
	if config.Insecure {
		httpClient.Transport = &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
	}

	// Create the client group config structure from the config file parsed
	// data
	for i := 0; i < len(config.GroupConfig); i++ {
		instanceData = append(instanceData, client.InstanceData{
			MinScore: config.GroupConfig[i].MinScore,

			HashBlacklistPath: config.GroupConfig[i].HashBlacklist,
			HashWhitelistPath: config.GroupConfig[i].HashWhitelist,
			IPBlacklistPath:   config.GroupConfig[i].IPBlacklist,
			IPWhitelistPath:   config.GroupConfig[i].IPWhitelist,
			URLBlacklistPath:  config.GroupConfig[i].URLBlacklist,
		})
	}
	

	// Create the apiClient and release objects

	apiClient := client.NewApiClient(config.URL, httpClient)
	release := client.NewRelease(apiClient, instanceData, GetLastSid())

	r := make(chan os.Signal, 1)
	signal.Notify(r, syscall.SIGHUP)

	go func() {
		for {
			<-r
			reload()
			// release.Reload(config.MinScore, listPath)
		}
	}()

	// Create a ticker with the specified interval
	ticker := time.NewTicker(time.Duration(config.Interval) * time.Second)

	// Listen for an interrupt signal to gracefully stop the loop
	interrupt := make(chan os.Signal, 1)
	signal.Notify(interrupt, os.Interrupt)
	for {
		select {
		case <-ticker.C:
			logrus.Debugf("Checking new release")
			if updated, err := release.Update(); err != nil {
				logrus.Error(err)
			} else {
				if err := release.Dump(); err != nil {
					logrus.Error(err)
				} else {
					if updated {
						notify()
					}
				}

				runtime.GC()
			}
		case <-interrupt:
			// Stop the loop and exit gracefully
			ticker.Stop()
			return
		}
	}

	if err = release.Init(); err != nil {
		logrus.Error(err)
	} else {
		logrus.Debugf("Saving data to file")
		if err = release.Dump(); err != nil {
			logrus.Error(err)
		} else {
			notify()
		}
	}
}

// notification to all snort instances.
func notify() {
	for i := 0; i < len(config.GroupConfig); i++ {

		if len(config.GroupConfig[i].SocketPath) > 0 {
			socket, err := net.Dial("unix", config.GroupConfig[i].SocketPath+
				"/instance-0/SNORT.sock")
			if err != nil {
				logrus.Warn(err)
				return
			}
			defer socket.Close()
			// If there is a file for IP send a IP reload notification to all snort instances
			if len(config.GroupConfig[i].IPBlacklist) > 0 {
				logrus.Debugf("[IpReload] -> Current instances -> "+strconv.FormatInt(int64(len(config.GroupConfig)), 10))
				for instance := 0; instance < len(config.GroupConfig); instance ++ {
					go func(instance int) {
						pararelNotify(
							instance,
							snortIPReloadCode,
							snortMessageTimeout,
						)
					}(instance)
				}
			}

			// If there is a file for HASHES send a HASH reload notification to all snort instances
			if len(config.GroupConfig[i].HashBlacklist) > 0 {
				logrus.Debugf("[HashReload] -> Current instances -> "+strconv.FormatInt(int64(len(config.GroupConfig)), 10))
				for instance := 0; instance < len(config.GroupConfig); instance++ {
					go func(instance int) {
						pararelNotify(
							instance,
							snortHashReloadCode,
							snortMessageTimeout,
						)
					}(instance)
				}
			}
			if len(config.GroupConfig[i].URLBlacklist) > 0 {
				logrus.Infof("[URL Reload], performing snortd reload...")
				UpdateRules()
			}
		}
	}
}

func reload() {
	logrus.Infof("Reloading")

	options, err := ioutil.ReadFile(configFileName)
	if err != nil {
		logrus.Fatal(err)
	}

	err = yaml.Unmarshal([]byte(options), &config)
	if err != nil {
		logrus.Fatal(err)
	}
}
