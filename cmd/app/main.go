package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"strconv"
	"syscall"
	"time"

	"github.com/Sirupsen/logrus"
	"gopkg.in/yaml.v2"

	"redborder/rb-malware-agent/client"
	"redborder/rb-malware-agent/snortcontrol"
)

////////////////
// Structures //
////////////////

// Config stores the general configuration for the app
type Config struct {
	URL           string `yaml:"url"`                  // API URL
	Interval      int    `yaml:"interval"`             // Interval between queries
	SocketTimeout int    `yaml:"snort_socket_timeout"` // Max time to wait for snort responses
	GroupConfig   []struct {
		MinScore      int    `yaml:"min_score"`         // Scores greater than this values are blacklisted
		IPBlacklist   string `yaml:"ip_blacklist"`      // Path for the file
		IPWhitelist   string `yaml:"ip_whitelist"`      // Path for the file
		HashBlacklist string `yaml:"hash_blacklist"`    // Path for the file
		HashWhitelist string `yaml:"hash_whitelist"`    // Path for the file
		SocketPath    string `yaml:"snort_socket_path"` // Path for the snort control socket
	} `yaml:"instances"`
}

////////////////////////////
// Constants and globals  //
////////////////////////////

const (
	snortIPReloadCode   = 1361 // Snort control code for IP reloading
	snortHashReloadCode = 1471 // Snort control code for HASH reloading
	snortMessageTimeout = 5000 // Max time to wait for snort responses
)

// Options stores the configuration of the application
var (
	githash        string // SHA from the current commit
	version        string // Current version of the app
	configFileName string // File name of the provided config file
	config         Config // Structure that stores the parsed configuration
)

///////////////
// Functions //
///////////////

// Used for parsing params and parse config file
func init() {
	debug := flag.Bool("debug", false, "Print debug info")
	versionFlag := flag.Bool("version", false, "Show version")
	configFileFlag := flag.String("config", "", "Config file")
	flag.Parse()

	if *versionFlag {
		fmt.Println("Version: " + version)
		fmt.Println("SHA: " + githash)
		os.Exit(0)
	}

	if *debug {
		logrus.SetLevel(logrus.DebugLevel)
	}

	configFileName = *configFileFlag

	if len(configFileName) == 0 {
		flag.Usage()
		os.Exit(0)
	}

	options, err := ioutil.ReadFile(configFileName)
	if err != nil {
		logrus.Fatal(err)
	}

	err = yaml.Unmarshal([]byte(options), &config)
	if err != nil {
		logrus.Fatal(err)
	}

	if len(config.URL) == 0 {
		logrus.Fatal("No URL provided")
	}
}

func main() {
	var err error
	var instanceData []client.InstanceData
	httpClient := &http.Client{}

	for i := 0; i < len(config.GroupConfig); i++ {
		instanceData = append(instanceData, client.InstanceData{
			MinScore: config.GroupConfig[i].MinScore,

			HashBlacklistPath: config.GroupConfig[i].HashBlacklist,
			HashWhitelistPath: config.GroupConfig[i].HashWhitelist,
			IPBlacklistPath:   config.GroupConfig[i].IPBlacklist,
			IPWhitelistPath:   config.GroupConfig[i].IPWhitelist,
		})
	}

	apiClient := client.NewApiClient(config.URL, httpClient)
	release := client.NewRelease(apiClient, instanceData)

	r := make(chan os.Signal, 1)
	signal.Notify(r, syscall.SIGHUP)

	go func() {
		for {
			<-r
			reload()
			// release.Reload(config.MinScore, listPath)
		}
	}()

	if err = release.Init(); err != nil {
		logrus.Error(err)
	} else {
		logrus.Debugf("Saving data to file")
		if err = release.Dump(); err != nil {
			logrus.Error(err)
		} else {
			notify()
		}
	}

	// Keep updating
	if config.Interval != 0 {
		for {
			select {
			case <-time.After(time.Duration(config.Interval) * time.Second):
				logrus.Debugf("Checking new release")
				if updated, err := release.Update(); err != nil {
					logrus.Error(err)
				} else {
					if err := release.Dump(); err != nil {
						logrus.Error(err)
					} else {
						if updated {
							notify()
						}
					}

					runtime.GC()
				}
			}
		}
	}
}

// notify sends an IP reload notification to snort instance 0 and HASH reload
// notification to all snort instances.
func notify() {
	for i := 0; i < len(config.GroupConfig); i++ {

		if len(config.GroupConfig[i].SocketPath) > 0 {
			socket, err := net.Dial("unix", config.GroupConfig[i].SocketPath+
				"/instance-0/SNORT.sock")
			if err != nil {
				logrus.Warn(err)
				return
			}
			defer socket.Close()

			// If there is a file for IP send a IP reload notification to snort
			if len(config.GroupConfig[i].IPBlacklist) > 0 {
				logrus.Debugf("Sending code: %d to %s/instance-0/SNORT.sock",
					snortIPReloadCode, config.GroupConfig[i].SocketPath)
				code, message, err := snortcontrol.Notify(
					socket,
					snortIPReloadCode,
					snortMessageTimeout,
				)
				if err != nil {
					logrus.Warn(err)
					return
				}

				if code != 0 {
					logrus.Warn("Snort notify error: " + message)
				}
			}

			// If there is a file for HASHES send a HASH reload notification to
			// all snort instances
			if len(config.GroupConfig[i].HashBlacklist) > 0 {
				i := 0
				for {
					if _, err := os.Stat(config.GroupConfig[i].SocketPath + "/instance-" +
						strconv.FormatInt(int64(i), 10) + "/SNORT.sock"); os.IsNotExist(err) {
						break
					}

					socket, err := net.Dial("unix",
						config.GroupConfig[i].SocketPath+"instance-"+
							strconv.FormatInt(int64(i), 10)+"/SNORT.sock")
					if err != nil {
						logrus.Warn(err)
					}
					defer socket.Close()

					logrus.Debugf("Sending code: %d to %s", snortHashReloadCode,
						"instance-"+strconv.FormatInt(int64(i), 10))
					snortcontrol.Notify(
						socket,
						snortHashReloadCode,
						snortMessageTimeout,
					)
					i++
				}
			}
		}
	}
}

func reload() {
	logrus.Infof("Reloading")

	options, err := ioutil.ReadFile(configFileName)
	if err != nil {
		logrus.Fatal(err)
	}

	err = yaml.Unmarshal([]byte(options), &config)
	if err != nil {
		logrus.Fatal(err)
	}
}
