// Copyright (C) 2016 Eneo Tecnologia S.L.
// Diego Fern√°ndez Barrera <bigomby@gmail.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"crypto/tls"
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"strconv"
	"syscall"
	"time"

	"github.com/Sirupsen/logrus"
	"gopkg.in/yaml.v2"

	"github.com/redBorder/rb-malware-agent/client"
	"github.com/redBorder/rb-malware-agent/snortcontrol"
)

////////////////
// Structures //
////////////////

// Config stores the general configuration for the app
type Config struct {
	URL           string `yaml:"url"`                  // API URL
	Interval      int    `yaml:"interval"`             // Interval between queries
	SocketTimeout int    `yaml:"snort_socket_timeout"` // Max time to wait for snort responses
	Insecure      bool   `yaml:"insecure"`             // Don't verify SSL cert
	GroupConfig   []struct {
		MinScore      int    `yaml:"min_score"`         // Scores greater than this values are blacklisted
		IPBlacklist   string `yaml:"ip_blacklist"`      // Path for the file
		IPWhitelist   string `yaml:"ip_whitelist"`      // Path for the file
		HashBlacklist string `yaml:"hash_blacklist"`    // Path for the file
		HashWhitelist string `yaml:"hash_whitelist"`    // Path for the file
		SocketPath    string `yaml:"snort_socket_path"` // Path for the snort control socket
	} `yaml:"instances"`
}

////////////////////////////
// Constants and globals  //
////////////////////////////

const (
	snortIPReloadCode   = 1361 // Snort control code for IP reloading
	snortHashReloadCode = 1471 // Snort control code for HASH reloading
	snortMessageTimeout = 5000 // Max time to wait for snort responses
)

// Options stores the configuration of the application
var (
	githash        string // SHA from the current commit
	version        string // Current version of the app
	configFileName string // File name of the provided config file
	config         Config // Structure that stores the parsed configuration
)

///////////////
// Functions //
///////////////

// Used for parsing params and parse config file
func init() {
	debug := flag.Bool("debug", false, "Print debug info")
	versionFlag := flag.Bool("version", false, "Show version")
	configFileFlag := flag.String("config", "", "Config file")
	flag.Parse()

	if *versionFlag {
		fmt.Println("Version: " + version)
		fmt.Println("SHA: " + githash)
		os.Exit(0)
	}

	if *debug {
		logrus.SetLevel(logrus.DebugLevel)
	}

	configFileName = *configFileFlag

	if len(configFileName) == 0 {
		flag.Usage()
		os.Exit(0)
	}

	options, err := ioutil.ReadFile(configFileName)
	if err != nil {
		logrus.Fatal(err)
	}

	err = yaml.Unmarshal([]byte(options), &config)
	if err != nil {
		logrus.Fatal(err)
	}

	if len(config.URL) == 0 {
		logrus.Fatal("No URL provided")
	}
}

func main() {
	var err error
	var instanceData []client.InstanceData
	httpClient := &http.Client{}

	// Set the client to skip SSL verification
	if config.Insecure {
		httpClient.Transport = &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
	}

	// Create the client group config structure from the config file parsed
	// data
	for i := 0; i < len(config.GroupConfig); i++ {
		instanceData = append(instanceData, client.InstanceData{
			MinScore: config.GroupConfig[i].MinScore,

			HashBlacklistPath: config.GroupConfig[i].HashBlacklist,
			HashWhitelistPath: config.GroupConfig[i].HashWhitelist,
			IPBlacklistPath:   config.GroupConfig[i].IPBlacklist,
			IPWhitelistPath:   config.GroupConfig[i].IPWhitelist,
		})
	}

	// Create the apiClient and release objects
	apiClient := client.NewApiClient(config.URL, httpClient)
	release := client.NewRelease(apiClient, instanceData)

	r := make(chan os.Signal, 1)
	signal.Notify(r, syscall.SIGHUP)

	go func() {
		for {
			<-r
			reload()
			// release.Reload(config.MinScore, listPath)
		}
	}()

	if err = release.Init(); err != nil {
		logrus.Error(err)
	} else {
		logrus.Debugf("Saving data to file")
		if err = release.Dump(); err != nil {
			logrus.Error(err)
		} else {
			notify()
		}
	}

	// Keep updating
	if config.Interval != 0 {
		for {
			select {
			case <-time.After(time.Duration(config.Interval) * time.Second):
				logrus.Debugf("Checking new release")
				if updated, err := release.Update(); err != nil {
					logrus.Error(err)
				} else {
					if err := release.Dump(); err != nil {
						logrus.Error(err)
					} else {
						if updated {
							notify()
						}
					}

					runtime.GC()
				}
			}
		}
	}
}

// notify sends an IP reload notification to snort instance 0 and HASH reload
// notification to all snort instances.
func notify() {
	for i := 0; i < len(config.GroupConfig); i++ {

		if len(config.GroupConfig[i].SocketPath) > 0 {
			socket, err := net.Dial("unix", config.GroupConfig[i].SocketPath+
				"/instance-0/SNORT.sock")
			if err != nil {
				logrus.Warn(err)
				return
			}
			defer socket.Close()

			// If there is a file for IP send a IP reload notification to all snort instances
			if len(config.GroupConfig[i].IPBlacklist) > 0 {
				logrus.Debugf("[IpReload] -> Current instances -> "+strconv.FormatInt(int64(len(config.GroupConfig)), 10))
				for instance := 0; instance < len(config.GroupConfig); instance ++ {

					logrus.Debugf("Will send signal to -> "+strconv.FormatInt(int64(instance), 10))
					if _, err := os.Stat(config.GroupConfig[instance].SocketPath + "/instance-" +
						strconv.FormatInt(int64(instance), 10) + "/SNORT.sock"); os.IsNotExist(err) {
						break
					}

					socket, err := net.Dial("unix",config.GroupConfig[instance].SocketPath+"instance-"+strconv.FormatInt(int64(instance), 10)+"/SNORT.sock")
					if err != nil {
						logrus.Warn(err)
					}
					defer socket.Close()

					logrus.Debugf("Sending code: %d to %s", snortIPReloadCode,
						"instance-"+strconv.FormatInt(int64(instance), 10))

					code, message, err := snortcontrol.Notify(
						socket,
						snortIPReloadCode,
						snortMessageTimeout,
					)

					if err != nil {
						logrus.Warn(err)
						return
					}
	
					if code != 0 {
						logrus.Warn("Snort notify error: " + message)
					}
				}

			}

			// If there is a file for HASHES send a HASH reload notification to all snort instances
			if len(config.GroupConfig[i].HashBlacklist) > 0 {
				logrus.Debugf("[HashReload] -> Current instances -> "+strconv.FormatInt(int64(len(config.GroupConfig)), 10))
				for instance := 0; instance < len(config.GroupConfig); instance++ {
					logrus.Debugf("Will send signal to -> "+strconv.FormatInt(int64(instance), 10))
					if _, err := os.Stat(config.GroupConfig[instance].SocketPath + "/instance-" +
						strconv.FormatInt(int64(instance), 10) + "/SNORT.sock"); os.IsNotExist(err) {
						break
					}

					socket, err := net.Dial("unix",config.GroupConfig[instance].SocketPath+"instance-"+strconv.FormatInt(int64(instance), 10)+"/SNORT.sock")
					if err != nil {
						logrus.Warn(err)
					}
					defer socket.Close()

					logrus.Debugf("Sending code: %d to %s", snortHashReloadCode,
						"instance-"+strconv.FormatInt(int64(instance), 10))

					code, message, err := snortcontrol.Notify(
						socket,
						snortHashReloadCode,
						snortMessageTimeout,
					)


					if err != nil {
						logrus.Warn(err)
						return
					}
	
					if code != 0 {
						logrus.Warn("Snort notify error: " + message)
					}
				}
			}
		}
	}
}

func reload() {
	logrus.Infof("Reloading")

	options, err := ioutil.ReadFile(configFileName)
	if err != nil {
		logrus.Fatal(err)
	}

	err = yaml.Unmarshal([]byte(options), &config)
	if err != nil {
		logrus.Fatal(err)
	}
}
