// Copyright (C) 2023 Eneo Tecnologia S.L.
// Diego Fernández Barrera <bigomby@gmail.com>
// Miguel Álvarez <malvarez@redborder.com>
// Miguel Negrón <manegron@redborder.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"crypto/tls"
	"flag"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"regexp"
	"net"
	"net/http"
	"os"
	"io"
	"os/signal"
	"runtime"
	"strconv"
	"time"
	"os/exec"
	"strings"
	"sort"
	"crypto/sha256"
	"github.com/Sirupsen/logrus"
	"gopkg.in/yaml.v2"
	"github.com/redBorder/rb-malware-agent/client"
	"github.com/redBorder/rb-malware-agent/snortcontrol"
)

////////////////
// Structures //
////////////////

// Config stores the general configuration for the app
type Config struct {
	URL           string `yaml:"url"`                  // API URL
	Interval      int    `yaml:"interval"`             // Interval between queries
	SocketTimeout int    `yaml:"snort_socket_timeout"` // Max time to wait for snort responses
	Insecure      bool   `yaml:"insecure"`             // Don't verify SSL cert
	VerifySnort   string `yaml:"snort_verify_script"`  // Script to verify snort instances config
	GroupConfig   []struct {
		MinScore           int    `yaml:"min_score"`          // Scores greater than this values are blacklisted
		IPBlacklist        string `yaml:"ip_blacklist"`       // Path for the file
		IPWhitelist        string `yaml:"ip_whitelist"`       // Path for the file
		HashBlacklist      string `yaml:"hash_blacklist"`     // Path for the file
		HashWhitelist      string `yaml:"hash_whitelist"`     // Path for the file
		URLBlacklist       string `yaml:"url_blacklist"`	  // Path for the file
		SocketPath         string `yaml:"snort_socket_path"`  // Path for the snort control socket
		SnortInstancePath  string `yaml:"snort_instance_path"`// Path for the snort instance
	} `yaml:"instances"`
}

////////////////////////////
// Constants and globals  //
////////////////////////////

const (
	snortIPReloadCode   = 1361 // Snort control code for IP reloading
	snortHashReloadCode = 1471 // Snort control code for HASH reloading
	snortMessageTimeout = 5000 // Max time to wait for snort responses
)

// Options stores the configuration of the application
var (
	githash        string // SHA from the current commit
	version        string // Current version of the app
	configFileName string // File name of the provided config file
	config         Config // Structure that stores the parsed configuration
)

///////////////
// Functions //
///////////////

// Used for parsing params and parse config file
func init() {
	debug := flag.Bool("debug", false, "Print debug info")
	versionFlag := flag.Bool("version", false, "Show version")
	configFileFlag := flag.String("config", "", "Config file")
	flag.Parse()

	if *versionFlag {
		fmt.Println("Version: " + version)
		fmt.Println("SHA: " + githash)
		os.Exit(0)
	}

	if *debug {
		logrus.SetLevel(logrus.DebugLevel)
	}

	configFileName = *configFileFlag

	if len(configFileName) == 0 {
		flag.Usage()
		os.Exit(0)
	}
	logrus.Debugf(configFileName)
	options, err := ioutil.ReadFile(configFileName)
	if err != nil {
		logrus.Fatal(err)
	}

	err = yaml.Unmarshal([]byte(options), &config)
	if err != nil {
		logrus.Fatal(err)
	}

	if len(config.URL) == 0 {
		logrus.Fatal("No URL provided")
	}
	if len(config.VerifySnort) == 0 {
		logrus.Fatal("No Snort Verify Script Provided")
	}
}

/*
	This function gets all snort bindings from a path
*/
func lookUpSnortBindings(dirPath string) ([]string, error) {
	var matches []string

	// Regular expression pattern to match directory names
	pattern := `snort-binding-\d+`

	// Walk through the directory and match the pattern
	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Check if the path is a directory and matches the pattern
		if info.IsDir() {
			matched, _ := regexp.MatchString(pattern, info.Name())
			if matched {
				matches = append(matches, path)
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return matches, err
}


/*
	This function get las sid from one snort instance.
*/
func fetchLastSIDFromDir(dirPath string, instance int, log bool) (int, error) {
	var lastSid int = 0
	var bindingIds []int
	snortBindings, err := lookUpSnortBindings(dirPath)

	if err != nil {
		logrus.Debugf("Could not lookup snort bindings")
		return 0, err
	}

	for i := 0; i < len(snortBindings); i++ {
		ruleFiles, err := filepath.Glob(filepath.Join(snortBindings[i], "*.rules"))
		if err != nil {
			logrus.Warn(err)
			return 0, err
		}
	
		if log {
			logrus.Debugf("Files in ->" + snortBindings[i] + " -> " + strconv.FormatInt(int64(len(ruleFiles)), 10))
		}
		// Regular expression to match the last SID value
		sidRegex := regexp.MustCompile(`sid:(\d+);`)
	
		// Iterate over each .rules file
		for _, file := range ruleFiles {
			if !strings.Contains(file, config.GroupConfig[instance].URLBlacklist) {
				//TODO: add check for not load urls.rules aka URLBlackList
				if log {
					logrus.Debugf("Looking for rules in ->" + file)
				}
				// Read the file content
				content, err := ioutil.ReadFile(file)
				if err != nil {
					return 0, err
				}
		
				// Find all matches of the SID regex in the file content
				matches := sidRegex.FindAllStringSubmatch(string(content), -1)
		
				// Extract the last SID value from each match and convert it to an integer
				for _, match := range matches {
					sid, err := strconv.Atoi(match[1])
					if err != nil {
						return 0, err
					}
					if sid > lastSid {
						lastSid = sid
					}
				}
				bindingIds = append(bindingIds, lastSid)
				lastSid = 0
			}
		}
		
		for i := 0; i < len(bindingIds); i++ {
			if bindingIds[i] > lastSid {
				lastSid = bindingIds[i]
			}
		}
	}
	return lastSid, nil
}

/*
	This function fetchs the offset of sid-msg.map file for not collide with another sid-msg in the map
*/
func fetchLastMapSIDFromDir(dirPath string, instance int, log bool) (int, error) {
	var offsetMap int

	ruleFiles, err := filepath.Glob(filepath.Join(dirPath, "sid-msg.map"))
	if err != nil {
		logrus.Warn(err)
		return 0, err
	}

	for _, ruleFile := range ruleFiles {
		content, err := ioutil.ReadFile(ruleFile)
		if err != nil {
			logrus.Warn(err)
			return 0, err
		}

		mapRegex := regexp.MustCompile(`(\d+)\s\|\|\s.+`)
		matches := mapRegex.FindAllStringSubmatch(string(content), -1)

		for _, match := range matches {
			mapid, err := strconv.Atoi(match[1])
			if err != nil {
				return 0, err
			}
			if mapid > offsetMap {
				offsetMap = mapid
			}
		}
	}

	return offsetMap, nil
}
/*
	This function get las sid from all the snort instances.
*/
func GetLastSid(log bool) int {
	var lastSid int = 0
	var instanceMapId int = 0
	for instance := 0; instance < len(config.GroupConfig); instance++ {
		SnortInstancePath := config.GroupConfig[instance].SnortInstancePath
		if log {
			logrus.Debugf("[yaml] -> Looking for rules in instance -> " + SnortInstancePath)
		}
		// Call fetchLastSIDFromDir to get the last SID from the directory
		instanceLastSid, err := fetchLastSIDFromDir(SnortInstancePath, instance, log)
		if err != nil {
			// Handle the error appropriately
			fmt.Println("Error:", err)
			return lastSid + instanceMapId
		}

		// Update the lastSid if a higher SID is found
		if instanceLastSid > lastSid {
			lastSid = instanceLastSid
		}
		if log {
			logrus.Debugf("[yaml] -> Looking for Last Mapped Rule in instance -> " + SnortInstancePath)
		}
		instanceLastMapSid, err := fetchLastMapSIDFromDir(SnortInstancePath, instance, log)
		if err != nil {
			fmt.Println("Error:", err)
			return lastSid + instanceMapId
		}

		if instanceLastMapSid > instanceMapId {
			instanceMapId = instanceLastMapSid
		}
	}
	logrus.Debugf("Got last rule id for the instances -> " +strconv.FormatInt(int64(lastSid), 10))
	logrus.Debugf("Got last Mapped id for the instances -> " +strconv.FormatInt(int64(instanceMapId), 10))
	logrus.Debugf("Will return the greather value for last SID...")
	if instanceMapId > lastSid {
		return instanceMapId
	} else {
		return lastSid
	}
}

/*
	This function removes GenMap generated ids
*/
func removeGenMap(path string) error {
	genMapPath := filepath.Join(path, "gen-msg.map")

	file, err := os.OpenFile(genMapPath, os.O_RDWR, 0644)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	content, err := ioutil.ReadAll(file)
	if err != nil {
		return fmt.Errorf("failed to read file: %w", err)
	}

	lines := strings.Split(string(content), "\n")
	var filteredLines []string

	regexPattern := regexp.MustCompile(`369\s\|\|\s.+`)

	for _, line := range lines {
		if !regexPattern.MatchString(line) {
			filteredLines = append(filteredLines, line)
		}
	}

	newContent := strings.Join(filteredLines, "\n")

	err = ioutil.WriteFile(genMapPath, []byte(newContent), 0644)
	if err != nil {
		return fmt.Errorf("failed to write to file: %w", err)
	}

	return nil
}


/*
	This function appends data to a file
*/
func appendToFile(path string, content string) error {
	file, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	_, err = fmt.Fprintln(file, content)
	if err != nil {
		return fmt.Errorf("failed to write to file: %w", err)
	}

	return nil
}

/*
	This function sets and generates the new maps
*/
func SetLastGenMappedString(instance int) error {
	err := removeGenMap(config.GroupConfig[instance].SnortInstancePath)
	if err != nil {
		return err
	}

	genMapPath := filepath.Join(config.GroupConfig[instance].SnortInstancePath, "gen-msg.map")
	urlsRulesPath := filepath.Join(config.GroupConfig[instance].URLBlacklist)

	// Read urls.rules and retrieve SIDs
	content, err := ioutil.ReadFile(urlsRulesPath)
	if err != nil {
		return fmt.Errorf("failed to read urls.rules: %w", err)
	}

	sidRegex := regexp.MustCompile(`sid:(\d+);`)
	sidMatches := sidRegex.FindAllStringSubmatch(string(content), -1)

	// Generate and append genmap entries for each SID
	for _, match := range sidMatches {
		sid, err := strconv.Atoi(match[1])
		if err != nil {
			return fmt.Errorf("failed to convert SID to integer: %w", err)
		}

		genMapEntry := fmt.Sprintf("369 || %d || RedBorder Malware Agent Malicious URL", sid)

		err = appendToFile(genMapPath, genMapEntry)
		if err != nil {
			return fmt.Errorf("failed to write to gen-msg.map: %w", err)
		}
	}

	return nil
}
/*
	This function spawns a new thread for notify snort paralel to other tasks
*/

func paralelNotify(instance, controlCode, timeout int) {
	logrus.Debugf("Will send signal to -> " + strconv.FormatInt(int64(instance), 10))
	if _, err := os.Stat(config.GroupConfig[instance].SocketPath + "/instance-" +
		strconv.FormatInt(int64(instance), 10) + "/SNORT.sock"); os.IsNotExist(err) {
		return
	}

	socket, err := net.Dial("unix", config.GroupConfig[instance].SocketPath+"instance-"+strconv.FormatInt(int64(instance), 10)+"/SNORT.sock")
	if err != nil {
		logrus.Warn(err)
	}
	defer socket.Close()

	logrus.Debugf("Sending code: %d to %s", controlCode,
		"instance-"+strconv.FormatInt(int64(instance), 10))

	code, message, err := snortcontrol.Notify(
		socket,
		controlCode,
		timeout,
	)

	if err != nil {
		logrus.Warn(err)
		return
	}

	if code != 0 {
		logrus.Warn("Snort notify error: " + message)
	}
}

/*
	This function reloads snortd service when new validated rules are present
*/
func UpdateRules(){

	// Command to execute
	logrus.Infof("Reloading snort, new url blacklist detected...")
	cmd := exec.Command("service", "snortd", "reload")

	// Run the command
	logrus.Debugf("Awaiting for snortd, main loop is blocked")
	err := cmd.Run()
	if err != nil {
		logrus.Fatal(err)
	}

	// Print a success message
	logrus.Infof("Snort service reloaded successfully.")
}

/*
	This function reloads barnyard2 service when new urls are present, so, it means
	that new gen-map is also present
*/
func reloadBarnyard2() {
	// Command to execute
	logrus.Infof("Reloading Barnyard2, new gen-map detected...")
	cmd := exec.Command("service", "barnyard2", "reload")

	// Run the command
	logrus.Debugf("Awaiting for barnyard2, main loop is blocked")
	err := cmd.Run()
	if err != nil {
		logrus.Fatal(err)
	}

	// Print a success message
	logrus.Infof("barnyard2 service reloaded successfully.")
}

/*
	This function order a string
*/
func orderString(s string) string {
	// Convert the string to a slice of characters
	slice := []rune(s)

	// Sort the slice in ascending order
	sort.Slice(slice, func(i, j int) bool {
		return slice[i] < slice[j]
	})

	// Convert the sorted slice back to a string
	orderedString := string(slice)

	return orderedString
}

/*
	This function calculates a SHA256 hash from a string
*/
func calculateHash(s string) string {
	// Calculate the SHA256 hash of the string
	hash := sha256.Sum256([]byte(s))

	// Convert the hash to a hexadecimal string
	hashString := fmt.Sprintf("%x", hash)

	return hashString
}

/*
	This function checks if we need snortd service to be reloaded
*/
func NeedReload(old_rules string, new_rules string) bool {
	logrus.Debugf("Checking if we need snortd service to be reloaded ...")
	orderedOldRules := orderString(old_rules)
	orderedNewRules := orderString(new_rules)

	// Calculate hash for each string
	oldRulesHash := calculateHash(orderedOldRules)
	logrus.Debugf("Got hash for old rules -> " + oldRulesHash)
	newRulesHash := calculateHash(orderedNewRules)
	logrus.Debugf("Got hash for new rules -> " + newRulesHash)
	return oldRulesHash != newRulesHash
}

/*
	This function read the URL rules
	param isMaf (bool) -> Malware Agent File
*/

func ReadRules(isMaf bool) string {
	var buffer string
	for i := 0; i < len(config.GroupConfig); i++ {
		if len(config.GroupConfig[i].URLBlacklist) > 0 {
			var data []byte
			var err error

			if isMaf {
				data, err = ioutil.ReadFile(config.GroupConfig[i].URLBlacklist + ".maf")
			} else {
				data, err = ioutil.ReadFile(config.GroupConfig[i].URLBlacklist)
			}

			if err != nil {
				fmt.Printf("Error reading file: %v", err)
			} else {
				buffer += string(data)
			}
		}
	}

	return buffer
}

/*
	This function copy snort rules to tmp file or to snort binding folder
*/
func copySnortRules(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	if err != nil {
		return err
	}

	return nil
}

/*
	This function checks the snortd config before performing
	the service reload
*/
func checkSnortConfig(newConfig string) bool {
	if len(newConfig) > 0 {
		copySnortRules(newConfig + ".maf", newConfig)
		canReload := true
		for i := 0; i < len(config.GroupConfig); i++ {
			command := config.VerifySnort
			args := []string{strconv.Itoa(i)}
			cmd := exec.Command(command, args...)

			if err := cmd.Run(); err != nil {
				canReload = false
				logrus.Debugf("[URL Reload] Failed to validate the new configuration, rolling back...: %v", err)
			} else {
				logrus.Debugf("[URL Reload] Valid config... ")
			}
		}

		if !canReload {
			tmpDir := os.TempDir()
			oldConfig := filepath.Join(tmpDir, "tmp_config")
			if _, err := os.Stat(oldConfig); os.IsNotExist(err) {
				// Copy an empty string to newConfig
				err := ioutil.WriteFile(newConfig, []byte{}, 0666)
				if err != nil {
					logrus.Debugf("[URL Reload] Failed to write empty string to new configuration file: %v", err)
				} else {
					logrus.Debugf("[URL Reload] Writing empty string to new config file %s", newConfig)
				}
				return canReload
			} else {
				tmpDir := os.TempDir()
				tmpConfig := filepath.Join(tmpDir, "tmp_config")
		
				err := copySnortRules(tmpConfig, newConfig)
				if err != nil {
					logrus.Debugf("[URL Reload] Failed to copy old config: %v", err)
				} else {
					logrus.Debugf("[URL Reload] Old config file copied to snort : %s", newConfig)
				}
			}
		} else {
			tmpDir := os.TempDir()
			tmpConfig := filepath.Join(tmpDir, "tmp_config")

			err := copySnortRules(newConfig, tmpConfig)
			if err != nil {
				logrus.Debugf("[URL Reload] Failed to copy new configuration file to temporary location: %v", err)
			} else {
				logrus.Debugf("[URL Reload] New configuration file copied to temporary location: %s", tmpConfig)
			}
		}

		return canReload
	}
	return false
}

func main() {
	var err error
	var instanceData []client.InstanceData
	httpClient := &http.Client{}

	// Set the client to skip SSL verification
	if config.Insecure {
		httpClient.Transport = &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
	}

	// Create the client group config structure from the config file parsed
	// data
	for i := 0; i < len(config.GroupConfig); i++ {
		instanceData = append(instanceData, client.InstanceData{
			MinScore: config.GroupConfig[i].MinScore,

			HashBlacklistPath: config.GroupConfig[i].HashBlacklist,
			HashWhitelistPath: config.GroupConfig[i].HashWhitelist,
			IPBlacklistPath:   config.GroupConfig[i].IPBlacklist,
			IPWhitelistPath:   config.GroupConfig[i].IPWhitelist,
			URLBlacklistPath:  config.GroupConfig[i].URLBlacklist,
		})
	}
	

	// Create the apiClient and release objects

	apiClient := client.NewApiClient(config.URL, httpClient)
	release := client.NewRelease(apiClient, instanceData, GetLastSid(true))

	// Create a ticker with the specified interval
	ticker := time.NewTicker(time.Duration(config.Interval) * time.Second)

	// Listen for an interrupt signal to gracefully stop the loop
	interrupt := make(chan os.Signal, 1)
	signal.Notify(interrupt, os.Interrupt)
	for {
		select {
		case <-ticker.C:
			logrus.Debugf("Checking new release")
			if updated, err := release.Update(); err != nil {
				logrus.Error(err)
			} else {
				oldRules := ReadRules(false);
				err := release.Dump();
				release.SetLastSid(GetLastSid(false));
				newRules := ReadRules(true); 
				if err != nil {
					logrus.Error(err)
				} else {
					if updated {
						notify(NeedReload(oldRules, newRules), release)
					}
				}

				runtime.GC()
			}
		case <-interrupt:
			// Stop the loop and exit gracefully
			ticker.Stop()
			return
		}
	}

	if err = release.Init(); err != nil {
		logrus.Error(err)
	} else {
		logrus.Debugf("Saving data to file")
		oldRules := ReadRules(false);
		err := release.Dump();
		newRules := ReadRules(true);
		if err != nil {
			logrus.Error(err)
		} else {
			notify(NeedReload(oldRules, newRules), release)
		}
	}
}

// notification to all snort instances.
func notify(reloadSnort bool, release client.Release) {
	for i := 0; i < len(config.GroupConfig); i++ {

		if len(config.GroupConfig[i].SocketPath) > 0 {
			socket, err := net.Dial("unix", config.GroupConfig[i].SocketPath+
				"/instance-0/SNORT.sock")
			if err != nil {
				logrus.Warn(err)
				return
			}
			defer socket.Close()
			// If there is a file for IP send a IP reload notification to all snort instances
			if len(config.GroupConfig[i].IPBlacklist) > 0 {
				logrus.Debugf("[IpReload] -> Current instances -> "+strconv.FormatInt(int64(len(config.GroupConfig)), 10))
				for instance := 0; instance < len(config.GroupConfig); instance ++ {
					go func(instance int) {
						paralelNotify(
							instance,
							snortIPReloadCode,
							snortMessageTimeout,
						)
					}(instance)
				}
			}
			logrus.Debugf("[UNIX SOCKET] -> Awaiting for UNIX Socket")
			time.Sleep(1 * time.Second)
			// If there is a file for HASHES send a HASH reload notification to all snort instances
			if len(config.GroupConfig[i].HashBlacklist) > 0 {
				logrus.Debugf("[HashReload] -> Current instances -> "+strconv.FormatInt(int64(len(config.GroupConfig)), 10))
				for instance := 0; instance < len(config.GroupConfig); instance++ {
					go func(instance int) {
						paralelNotify(
							instance,
							snortHashReloadCode,
							snortMessageTimeout,
						)
					}(instance)
				}
			}
			logrus.Debugf("[UNIX SOCKET] -> Awaiting for UNIX Socket")
			time.Sleep(1 * time.Second)
			if len(config.GroupConfig[i].URLBlacklist) > 0 {
				if reloadSnort {
					logrus.Infof("[URL Reload] Checking snort config...")
					if checkSnortConfig(config.GroupConfig[i].URLBlacklist) {
						logrus.Infof("[URL Reload] Snort [OK]")
						SetLastGenMappedString(i)
						logrus.Infof("[URL Reload] performing snortd reload...")
						UpdateRules()
						logrus.Infof("[URL Reload] performing barnyard2 reload...")
						reloadBarnyard2()
					} else {
						logrus.Infof("[URL Reload] Snort Config is invalid...")
						logrus.Infof("[URL Reload] Reseting snort rule id")
						release.SetLastSid(GetLastSid(true))	
					}
				} else {
					logrus.Infof("[URL Reload] rb-reputation and snort rules are the same, ignoring service reload...")
					logrus.Infof("[URL Reload] Reseting snort rule id")
					release.SetLastSid(GetLastSid(true))	
				}
			}
		}
	}
}