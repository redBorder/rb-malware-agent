// Copyright (C) 2023 Eneo Tecnologia S.L.
// Diego Fernández Barrera <bigomby@gmail.com>
// Miguel Álvarez <malvarez@redborder.com>
// Miguel Negrón <manegron@redborder.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package snortcontrol

import (
	"bytes"
	"encoding/binary"
	"net"
	"testing"

	"github.com/stretchr/testify/assert"
)

type handler func(c net.Conn, res chan []byte)

func startServer(l net.Listener, h handler, res chan []byte) {

	go func() {
		var fd net.Conn
		var err error
		for {
			fd, err = l.Accept()
			if err != nil {
				return
			}
			h(fd, res)
		}
	}()

	return
}

func Test_Notify_Success(t *testing.T) {
	l, err := net.Listen("unix", "/tmp/test1.sock")
	if err != nil {
		t.Error(err.Error())
		return
	}
	defer l.Close()

	h := func(c net.Conn, res chan []byte) {
		response := new(bytes.Buffer)
		buf := make([]byte, 512)

		binary.Write(response, binary.BigEndian, int16(1))
		binary.Write(response, binary.BigEndian, int16(0))
		binary.Write(response, binary.BigEndian, int32(0))

		nr, err := c.Read(buf)
		if err != nil {
			return
		}

		data := buf[0:nr]
		_, err = c.Write(response.Bytes())
		if err != nil {
			t.Error(err.Error())
		}
		res <- data
	}

	res := make(chan []byte)
	startServer(l, h, res)

	c, err := net.Dial("unix", "/tmp/test1.sock")
	if err != nil {
		t.Error(err.Error())
		return
	}
	defer c.Close()

	validCode := 1361
	code, message, err := Notify(c, validCode, 5)

	r := <-res

	// Response bytes
	assert.NoError(t, err)
	assert.Equal(t, 0, code, "No error expected")
	assert.Equal(t, "", message)

	// Sent bytes
	assert.Equal(t, byte(0), r[0])
	assert.Equal(t, byte(0x1), r[1])
	assert.Equal(t, byte(0x5), r[2])
	assert.Equal(t, byte(0x51), r[3])
	assert.Equal(t, byte(0x0), r[4])
	assert.Equal(t, byte(0x0), r[5])
	assert.Equal(t, byte(0x0), r[6])
	assert.Equal(t, byte(0x0), r[7])
}

func Test_Notify_Fail(t *testing.T) {
	l, err := net.Listen("unix", "/tmp/test2.sock")
	if err != nil {
		t.Error(err.Error())
		return
	}
	defer l.Close()

	h := func(c net.Conn, res chan []byte) {
		buf := make([]byte, 512)
		nr, err := c.Read(buf)
		if err != nil {
			return
		}

		response := new(bytes.Buffer)
		message := "This is an error"
		binary.Write(response, binary.BigEndian, int16(1))              // Version
		binary.Write(response, binary.BigEndian, int16(1))              // Type
		binary.Write(response, binary.BigEndian, int32(len(message)+6)) // Length
		binary.Write(response, binary.BigEndian, int32(0))              // Code
		binary.Write(response, binary.BigEndian, int16(len(message)))   // length
		binary.Write(response, binary.BigEndian, []byte(message))       // Message

		data := buf[0:nr]
		_, err = c.Write(response.Bytes())
		if err != nil {
			t.Error(err.Error())
		}
		res <- data
	}

	res := make(chan []byte)
	startServer(l, h, res)

	c, err := net.Dial("unix", "/tmp/test2.sock")
	if err != nil {
		t.Error(err.Error())
		return
	}
	defer c.Close()

	invalidCode := 1361
	code, message, err := Notify(c, invalidCode, 5)

	r := <-res

	// Response bytes
	assert.NoError(t, err)
	assert.NotEqual(t, 0, code, "An error was expected")
	assert.Equal(t, "This is an error", message)

	// Sent bytes
	assert.Equal(t, byte(0), r[0])
	assert.Equal(t, byte(0x1), r[1])
	assert.Equal(t, byte(0x5), r[2])
	assert.Equal(t, byte(0x51), r[3])
	assert.Equal(t, byte(0x0), r[4])
	assert.Equal(t, byte(0x0), r[5])
	assert.Equal(t, byte(0x0), r[6])
	assert.Equal(t, byte(0x0), r[7])
}

func Test_Notify_InvalidSocket(t *testing.T) {
	_, _, err := Notify(nil, 1361, 5)
	assert.Error(t, err)
}
