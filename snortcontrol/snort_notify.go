// Copyright (C) 2023 Eneo Tecnologia S.L.
// Diego Fernández Barrera <bigomby@gmail.com>
// Miguel Álvarez <malvarez@redborder.com>
// Miguel Negrón <manegron@redborder.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package snortcontrol

import (
	"bytes"
	"encoding/binary"
	"errors"
	"io"
	"net"
	"time"

	"github.com/Sirupsen/logrus"
)

const (
	SNORT_HDR_VERSION = 1
)

type SnortMessage struct {
	version int16
	msgType int16
	length  int32
}

type Response struct {
	code    int
	message string
}

func Notify(socket net.Conn, code, timeout int) (resCode int, resMessage string, err error) {
	var buf bytes.Buffer

	if socket == nil {
		err = errors.New("Invalid socket")
		return
	}

	ch := make(chan *Response)

	msg := SnortMessage{
		version: int16(SNORT_HDR_VERSION),
		msgType: int16(code),
		length:  int32(0),
	}

	go reader(socket, ch)

	binary.Write(&buf, binary.BigEndian, msg)

	if _, err = socket.Write(buf.Bytes()); err != nil {
		return
	}

	select {
	case res := <-ch:
		resCode = res.code
		resMessage = res.message
		return
	case <-time.After(time.Duration(timeout) * time.Second):
		err = errors.New("Timeout occurred")
		return
	}
}

func reader(r io.Reader, ch chan *Response) {
	buf := make([]byte, 1024)

	n, err := r.Read(buf[:])
	if err != nil {
		logrus.Warn(err)
		return
	}

	res := &Response{}

	msgTypeBytes := buf[2:4]
	res.code = int(binary.BigEndian.Uint16(msgTypeBytes))
	msgLengthBytes := buf[12:14]
	msgLength := binary.BigEndian.Uint16(msgLengthBytes)

	if msgLength > 0 {
		msgDataBytes := buf[14:n]
		res.message = string(msgDataBytes)
	} else {
		res.message = ""
	}

	ch <- res
}
